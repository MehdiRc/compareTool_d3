<!DOCTYPE html>
<html>

<head>
    <title>D3 Table</title>
    <!-- Importing D3.js libraries for data visualization and manipulation -->
    
    <script src="https://d3js.org/d3.v5.min.js"></script>
    <script src="https://d3js.org/d3-dsv.v1.min.js"></script>
    <script src="https://d3js.org/d3-scale.v3.min.js"></script>
    <!-- Styling the table, headers, and cells -->
    <style>
        table,
        th,
        td {
            border: 1px solid black;
            border-collapse: collapse;
        }

        th {
            cursor: pointer;  /* Makes the cursor a hand when hovering over table headers */
        }

        input[type=range].disabled {
            background-color: #ddd;  /* Gray background for disabled sliders */
        }
    </style>
    <style>
        table.mapping-table {
            display: grid;
            grid-template-rows: auto auto repeat(auto-fill, 1fr) auto;
        }
        table.mapping-table thead,
        table.mapping-table tbody,
        table.mapping-table tr {
            display: contents;
        }

        table.mapping-table th,
        table.mapping-table td {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .table-cell {
            position: relative;
        }
        
        .table-cell:has(.cell-label) {
            color : transparent;
            padding : 0 6px;
        }

        .mean-row {
            border-top: 5px solid #000000; /* Black top border */
            border-bottom: 5px solid #000000; /* Black bottom border */
            border-style: double;
        }
        .mean-row td, .mean-row th {
            border-top: 5px solid #000000;
            border-bottom: 5px solid #000000;
            border-style: double;
        }

        .score {
            
            border-left: 5px solid #000000; /* Black top border */
            border-right: 5px solid #000000; /* Black bottom border */
            border-style: double;
        }
        .score td, .score th {
            border-left: 5px solid #000000;
            border-right: 5px solid #000000;
            border-style: double;
        }

        .min-range{
            display: none;
        }
        .max-range{
            display: none;
        }

        
        .cell-label {
            position: absolute;
            z-index: 10;

            left : 0;
            right : 0;
            top : 0;
            bottom : 0;
            display: flex;
            align-items: center;
            justify-content: center;
            color : black;

            width: 100%;
        }

        .progress-bar {
            position: absolute;
            z-index: 1;

            bottom: 0;
            left: 0;
            top: 0;
            
        }

        table{
            table-layout:fixed; /* same width will be applied to both the tables*/
        }

        .collapsible {
            background-color: #777777;
            color: white;
            cursor: pointer;
            padding: 2px;
            width: 100%;
            border: none;
            text-align: left;
            outline: none;
            font-size: 15px;
            
        }

        .active{
            background-color: #777777;
        } 
        
        .collapsible:hover {
            background-color: #555;
        }

        .content {
            padding: 0 18px;
            display: none;
            overflow: hidden;
            background-color: #f1f1f1;
            
            grid-template-columns: repeat(4, 1fr); /* Creates columns of minimum 200px and as many as can fit */
            gap: 10px; /* Adjust spacing between items */
        }




    </style>
</head>
<body>
    <!-- File input for CSV file -->
    <input type="file" id="csvFile" name="csvFile" accept=".csv,.json" multiple>
    

    <script>
        // Variables
        // fileInput: Selects the file input element to listen for changes (file uploads)
        
        // sortOrder: Keeps track of the current sorting order (0: original, 1: ascending, 2: descending)
        // sortColumn: Keeps track of the column that is currently sorted
        
        // priorities: Stores the priority (importance) assigned to each column
        // idealValues: Stores the ideal (best) value for each column
        // categoricalMappings: Stores the mappings from categorical values to scores

        // includedColumns: Stores whether each column is included in the score calculation

        // resizeMode: Global variable to track the current resizing mode
        
        // globalMin: Stores the minimum value for each column
        // globalMax: Stores the maximum value for each column
        
        // tableList: Stores the data for each table
        // fileNames: Stores the names of the files
        
        // activateHistograms: Stores whether histograms are activated
        // activateColors: Stores whether colors are activated
        // activatePriority: Stores whether priority is activated
        // activateScores: Stores whether scores are activated
       

        var activateHistograms = true;

        var activateColors = true;
        var colorMetric = "Distance"; // Distance, Priority, DistanceXPriority
        
        var activateBars = true;
        var barsMetric = "Priority"; // Distance,  Priority, DistanceXPriority

        var activateOpacity = true;
        var opacityMetric = "Priority"; // Distance,  Priority, DistanceXPriority

        var activatePriority = true;
        var activateScores = true;
        
        var activateTOffPriorityMode = true;
        
        // Restrict the settings makes them invisible
        var restrictedMode = false;
        

        


        var fileInput = d3.select("#csvFile");
        

        var priorities = {};
        var idealValues = {};
        var includedColumns = {};
        var categoricalMappings = {};
        
        var globalMin = {};
        var globalMax = {};

        var minRangeValues = {};
        var maxRangeValues = {};

        var tableList = [];

        var fileNames = []; 

        // <!-- ! Function to read the file and parse the CSV data -->
        async function readFile(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = function(e) {
                    resolve(e.target.result);
                };
                reader.onerror = function(e) {
                    // Rejecting the promise if there's an error
                    reject(new Error("File reading failed"));
                };
                reader.readAsText(file);
            });
        }

        // <!-- ! Function to read multiple files and parse the CSV data -->
        async function readFiles(files) {
            const texts = [];
            
            for (let i = 0; i < files.length; i++) {
                texts.push(await readFile(files[i]))
            }
            return texts
        }

        // <!-- ! Function to load the files and create the table -->
        function load(texts) {
            // This function is called when the files are loaded      
            tableList = [];
            priorities = {};
            idealValues = {};
            includedColumns = {};
            categoricalMappings = {};
        
            globalMin = {};
            globalMax = {};

            tableList = [];

            activateHistograms = true;
            activateColors = true;
            activateBars = true;
            activateOpacity = true;
            activatePriority = true;
            activateScores = true;
            activateTOffPriorityMode = true;

            colorMetric = "Distance"; // Distance, Priority, DistanceXPriority
            barsMetric = "Priority"; // Distance,  Priority, DistanceXPriority
            opacityMetric = "Priority"; // Distance,  Priority, DistanceXPriority

            histBinFunction = "sturges"; // sturges, scott, freedmanDiaconis
            
            
            
            d3.selectAll("body > *:not(input[type='file'])").remove();
        
            for (let i = 0; i < texts.length; i++) {
                const text = texts[i]
                const data = d3.csvParse(text)
                onData(data, i)
            }

            try {
                //<!-- * this is where the buttons and checkboxes are created
                
                var body = d3.select("body");

                // Add buttons to save a state
                d3.select("body").append("input")
                    .attr("type", "button")
                    .attr("id", "saveState")
                    .attr("value", "Save State ðŸ’¾")
                    .style("display", restrictedMode ? "none" : "block")
                    .on("click", saveState);

                // Add buttons to load a state
                d3.select("body").append("label")
                    .attr("for", "loadState")
                    .text("Load State â®°")
                    .style("display", "inline-block")
                    .style("padding", "1px 5px")
                    .style("font-size", "16px")
                    .style("cursor", "pointer")
                    .style("background-color", "#4CAF50") // Green
                    .style("color", "white")
                    .style("border", "none")
                    .style("text-align", "center")
                    .style("text-decoration", "none")
                    .style("display", restrictedMode ? "none" : "block")    
                    .on("mouseover", function() {
                        d3.select(this).style("background-color", "#45a049");
                    })
                    .on("mouseout", function() {
                        d3.select(this).style("background-color", "#4CAF50");
                    });

                // Add the file selection input for loading a task
                d3.select("body").append("input")
                    .attr("type", "file")
                    .attr("id", "loadState")
                    .attr("accept", ".json")
                    .attr("multiple", null)
                    .style("display", restrictedMode ? "none" : "block")
                    .on("change", async function () {
                        const files = this.files
                        const jsonFile = Array.from(files).filter(file => file.name.endsWith('.json'));
                        const savetexts = await readFiles(jsonFile);
                        if(savetexts.length == 1){
                            loadState(savetexts[0]);
                        }else if(savetexts.length > 1){
                            alert("Only one state JSON can be loaded at a time \nJSON files will be ignored");
                        }
                    });

                // Append the button that will control the collapsible section
                body.append("button")
                    .attr("type", "button")
                    .attr("class", "collapsible")
                    .text("â–¼ Open Settings")
                    .style("display", restrictedMode ? "none" : "block")
                    // Collapsible functionality
                    .on("click", function() {
                        //Here
                        this.classList.toggle("active");
                        var content = this.nextElementSibling;
                        if (content.style.display === "grid") {
                            content.style.display = "none";
                            this.innerText = "â–¼ Open Settings";
                        } else {
                            content.style.display = "grid";
                            this.innerText = "â–² Close Settings";
                        }
                    });
                    

                // Append the div that will contain the collapsible content
                var content = body.append("div")
                    .attr("class", "content")
                    .style("display", "none"); // Start with the content hidden



                
                // <!-- ~ this is a collapsible section that contains the settings for the table
                var contentDiv = d3.select(".content");

                


                // Add checkboxes to activate/deactivate Histograms
                var check1 = contentDiv.append("div")
                check1.append("input")
                    .attr("type", "checkbox")
                    .attr("id", "activateHistograms")
                    .attr("name", "activateHistograms")
                    .property("checked", true)
                    .on("change", function(d, i) { 
                        activateHistograms = d3.select(this).property("checked")
                        if(!activateHistograms){
                            for (let j= 0 ; j < tableList.length;j++){
                                d3.selectAll("#histogramRow"+j).remove();
                            }
                            
                            
                        }else{
                            for (let j= 0 ; j < tableList.length;j++){
                                createHistograms(tableList[j]);
                            }
                        }
                    });  
                // Add label activate/deactivate Histograms
                check1.append("label")
                    .attr("for", "activateHistograms")
                    .text("Activate Histograms");

                    
                // Add checkboxes to activate/deactivate Priority
                var check2 = contentDiv.append("div")
                check2.append("input")
                    .attr("type", "checkbox")
                    .attr("id", "activatePriority")
                    .attr("name", "activatePriority")
                    .property("checked", true)
                    .on("change", function(d, i) { 
                        activatePriority = d3.select(this).property("checked")
                        if(activatePriority){
                            for (let j= 0 ; j < tableList.length;j++){
                                // Change the opacity of the cell based on the priority of the column
                                tableList[j].rows.selectAll("td").selectAll(".progress-bar")
                                .data(priorities[d.column])
                                .style("width", function(d) {  //TODO:  modify midth parameter of 'progress bar' div
                                    
                                    if(includedColumns[d.column] && d.column!== "Score" ){
                                        return priorities[d.column]+"%" ;
                                    }
                                    else if(d.column === "Score"){
                                        return 1;
                                    }
                                    else{
                                        return 0.5;
                                    }
                                    
                                });
                            }
                        }else{
                            for (let j= 0 ; j < tableList.length;j++){
                                tableList[j].rows.selectAll("td").style("opacity", 1);
                            }
                        }
                        
                    });
                // Add label activate/deactivate Priority
                check2.append("label")
                    .attr("for", "activatePriority")
                    .text("Activate Priority");
                

                // Add checkboxes to activate/deactivate TOff Priority Mode
                var check3 = contentDiv.append("div")
                check3.append("input")
                    .attr("type", "checkbox")
                    .attr("id", "activateTOffPriorityMode")
                    .attr("name", "activateTOffPriorityMode")
                    .property("checked", true)
                    .on("change", function(d, i) { 
                        activateTOffPriorityMode = d3.select(this).property("checked")
                    });
                // Add label activate/deactivate TOff Priority Mode
                check3.append("label")
                    .attr("for", "activateTOffPriorityMode")
                    .text("Activate priority normalization");
                    

                // Add checkboxes to activate/deactivate Scores
                var check5 = contentDiv.append("div")
                check5.append("input")
                    .attr("type", "checkbox")
                    .attr("id", "activateScores")
                    .attr("name", "activateScores")
                    .property("checked", true)
                    .on("change", function(d, i) { 
                        activateScores = d3.select(this).property("checked")
                        resetScoreMinMax();
                        for (let j= 0 ; j < tableList.length;j++){
                            updateScores(tableList[j]);
                        }
                        for (let j= 0 ; j < tableList.length;j++){
                            updateHistogram(tableList[j]);
                        }
                    });
                // Add label activate/deactivate Scores
                check5.append("label")
                    .attr("for", "activateScores")
                    .text("Activate Scores");  


                // Add checkboxes to activate/deactivate Colors
                var check4 = contentDiv.append("div")
                check4.append("input")
                    .attr("type", "checkbox")
                    .attr("id", "activateColors")
                    .attr("name", "activateColors")
                    .property("checked", true)
                    .on("change", function(d, i) { 
                        activateColors = d3.select(this).property("checked")
                        for (let j= 0 ; j < tableList.length;j++){
                            updateColors(tableList[j]);
                            updateHistogramColors(tableList[j]);
                        }
                    });
                // Add label activate/deactivate Colors
                check4.append("label")
                    .attr("for", "activateColors")
                    .text("Activate Colors");

                
                var colorDropdownDiv = contentDiv.append("div") 
                //Add a label for the color metric dropdown
                colorDropdownDiv.append("label")
                    .attr("for", "colorMetricSelect")
                    .text("Color Metric");
                //Add a dropdown to select the color metric
                var colorDropdown = colorDropdownDiv.append("select")
                    .attr("name", "colorMetricSelect")
                    .on("change", function() {
                        colorMetric = this.value;
                    });

                colorDropdown.append("option")
                    .attr("value", "Distance")
                    .text("Distance from ideal");

                colorDropdown.append("option")
                    .attr("value", "Priority")
                    .text("Priority");

                colorDropdown.append("option")
                    .attr("value", "DistanceXPriority")
                    .text("Priority x Distance");

                colorDropdown.property('value', colorMetric);

                var check6 = contentDiv.append("div")
                check6.append("input")
                    .attr("type", "checkbox")
                    .attr("id", "activateBars")
                    .attr("name", "activateBars")
                    .property("checked", true)
                    .on("change", function(d, i) { 
                        activateBars = d3.select(this).property("checked")
                        for (let j= 0 ; j < tableList.length;j++){
                            updateColors(tableList[j]);
                        }
                    });
                // Add label activate/deactivate Bars
                check6.append("label")
                    .attr("for", "activateBars")
                    .text("Activate Bars");
                var barDropdownDiv = contentDiv.append("div")
                //Add a label for the bars metric dropdown
                barDropdownDiv.append("label")
                    .attr("for", "barsMetricSelect")
                    .text("Bars Metric"); 
                //Add a dropdown to select the bars metric
                var barDropdown = barDropdownDiv.append("select")
                .attr("name", "barsMetricSelect")
                .on("change", function() {
                    barsMetric = this.value;
                });

                barDropdown.append("option")
                    .attr("value", "Distance")
                    .text("Distance from ideal");

                barDropdown.append("option")
                    .attr("value", "Priority")
                    .text("Priority");

                barDropdown.append("option")
                    .attr("value", "DistanceXPriority")
                    .text("Priority x Distance");

                barDropdown.property('value', barsMetric);

                //Add a checkbox to activate/deactivate Opacity
                var check7 = contentDiv.append("div")
                check7.append("input")
                    .attr("type", "checkbox")
                    .attr("id", "activateOpacity")
                    .attr("name", "activateOpacity")
                    .property("checked", true)
                    .on("change", function(d, i) { 
                        activateOpacity = d3.select(this).property("checked")
                        for (let j= 0 ; j < tableList.length;j++){
                            updateColors(tableList[j]);
                        }
                    });
                // Add label activate/deactivate Opacity
                check7.append("label")
                    .attr("for", "activateOpacity")
                    .text("Activate Opacity");
                
                var opacityDropdownDiv = contentDiv.append("div")
                //Add a label for the opacity metric dropdown
                opacityDropdownDiv.append("label")
                    .attr("for", "opacityMetricSelect")
                    .text("Opacity Metric");
                //Add a dropdown to select the opacity metric
                var opacityDropdown = opacityDropdownDiv.append("select")
                    .attr("name", "opacityMetricSelect")
                    .on("change", function() {
                        opacityMetric = this.value;
                    });
                opacityDropdown.append("option")
                    .attr("value", "Distance")
                    .text("Distance from ideal");
                opacityDropdown.append("option")
                    .attr("value", "Priority")
                    .text("Priority");
                opacityDropdown.append("option")
                    .attr("value", "DistanceXPriority")
                    .text("Priority x Distance");
                
                opacityDropdown.property('value', opacityMetric);

                var binDropdownDiv = contentDiv.append("div")
                // add a label for the type of histogram binning
                binDropdownDiv.append("label")
                    .attr("for", "histBinFunction")
                    .text("Hist. Bin. Func.");
                // add a dropdown to select the type of histogram binning
                var histBinFunctionDropdown = binDropdownDiv.append("select")
                    .attr("name", "histBinFunction")
                    .on("change", function() {
                        histBinFunction = this.value;
                        for (let j= 0 ; j < tableList.length;j++){
                            d3.selectAll("#histogramRow"+j).remove();
                            createHistograms(tableList[j]);
                        }
                    });
                histBinFunctionDropdown.append("option")
                    .attr("value", "sturges")
                    .text("Sturges");
                histBinFunctionDropdown.append("option")
                    .attr("value", "scott")
                    .text("Scott");
                histBinFunctionDropdown.append("option")
                    .attr("value", "freedmanDiaconis")
                    .text("Freedman-Diaconis");
                
                

                createSliderTable();

                for (let i = 0; i < tableList.length; i++) {
                    createDataTable(tableList[i]);
                    createHistograms(tableList[i]);
                }
            } catch(error) {
                console.error("An error occurred while processing the files:", error);
            }
        }

        // Event listener for file input change
        // When a file is selected, it reads the file, parses the CSV data, and calls processData
        fileInput.on("change", async function () {
            const files = this.files

            const csvFiles = Array.from(files).filter(file => file.name.endsWith('.csv'));
            const jsonFile = Array.from(files).filter(file => file.name.endsWith('.json'));

            fileNames = csvFiles.map(file => file.name); // Get the names of the CSV files

            const texts = await readFiles(csvFiles);
            if (texts.length == 0){
                alert("No CSV files selected");
                return;
            }
            load(texts);
            const savetexts = await readFiles(jsonFile);
            if(savetexts.length == 1){
                loadState(savetexts[0]);
            }else if(savetexts.length > 1){
                alert("Only one state JSON can be loaded at a time \nJSON files will be ignored \nYou can load a JSON with the 'Load State' button");
            }
            fileInput.style("display", restrictedMode ? "none" : "block")
            //localStorage.setItem('files', JSON.stringify(texts));
        });

        const params = new URLSearchParams(document.location.search);
        const hotreload = params.get('hotreload');
        if (hotreload && localStorage.getItem('files')) {
            load(JSON.parse(localStorage.getItem('files')))
        }

        function onData(data, i) {
            var newTable = {};
            //Data
            newTable.index = i;
            newTable.name = fileNames[i]; //new
            
            newTable.keys = d3.keys(data[0]);
            newTable.data = data;
            newTable.originalData = JSON.parse(JSON.stringify(data));// Creating a deep copy of the original data for reference // This is done to keep an unchanged version of the data, which might be useful for future features or debugging
            newTable.numericValues = {}
            newTable.minVal = {}
            newTable.maxVal = {}
            newTable.columnMeans = {}
            newTable.position = {
                "top":  200 + 150*i+"px",
                "left": 100 + 150*i+"px",
                "z-index": 0
            }


            //Sorting options
            newTable.sortOrder = 0;
            newTable.sortColumn = null;
            newTable.resizeMode = 'both';  // both, hide, or free
            newTable.pin = false; //new

            //Visual elements
            newTable.mydiv = null;
            newTable.mydivheader = null;
            newTable.scrolldiv = null;
            newTable.resizer = null;
            newTable.dataTable = null;
            newTable.headers = null;
            newTable.dataThead = null;
            newTable.histogramRow = null;
            newTable.dataTbody = null;
            newTable.rows = null;
            newTable.cells = null;


            for (let i = 0; i < newTable.keys.length; i++) {
                // Extracting numeric values from the column
                newTable.numericValues[newTable.keys[i]] = data.map(function (row) {
                    return parseFloat(row[newTable.keys[i]]);
                }).filter(function (val) {
                    return !isNaN(val);
                });

                newTable.minVal[newTable.keys[i]] = d3.min(newTable.numericValues[newTable.keys[i]]);
                newTable.maxVal[newTable.keys[i]] = d3.max(newTable.numericValues[newTable.keys[i]]);
                
                
                if ( !(newTable.keys[i]  in globalMin) || globalMin[newTable.keys[i]] > newTable.minVal[newTable.keys[i]]){
                    globalMin[newTable.keys[i]] = newTable.minVal[newTable.keys[i]];
                }
                if ( !(newTable.keys[i] in globalMax) || globalMax[newTable.keys[i]] < newTable.maxVal[newTable.keys[i]]){
                    globalMax[newTable.keys[i]] = newTable.maxVal[newTable.keys[i]];
                }




            }
            newTable.minVal["Score"] = 0;
            newTable.maxVal["Score"] = 0;

            tableList.push(newTable);
        }

        // Function to serialize and save the state
        function saveState() {
    
            const state = {
                
                
                // Serialize simple variables
                activateHistograms: activateHistograms,
                activateColors: activateColors,
                activateBars: activateBars,
                activateOpacity: activateOpacity,
                activatePriority: activatePriority,
                activateScores: activateScores,
                activateTOffPriorityMode: activateTOffPriorityMode,

                colorMetric: colorMetric,
                barsMetric: barsMetric,
                opacityMetric: opacityMetric,

                priorities: priorities,
                idealValues: idealValues,
                includedColumns: includedColumns,
                categoricalMappings: categoricalMappings,
                globalMin: globalMin,
                globalMax: globalMax,

                minRangeValues: minRangeValues,
                maxRangeValues: maxRangeValues,

                fileNames: fileNames,
                
                // Serialize tableList excluding non-serializable properties
                
                tableList: tableList.map(table => ({
                    index: table.index,
                    name: table.name,
                    keys: table.keys,
                    data: table.data,
                    originalData: table.originalData,
                    numericValues: table.numericValues,
                    minVal: table.minVal,
                    maxVal: table.maxVal,
                    columnMeans: table.columnMeans,

                    sortOrder: table.sortOrder,
                    sortColumn: table.sortColumn,
                    resizeMode: table.resizeMode,
                    position: table.position,
                    
                })),
                
            };

            const stateJSON = JSON.stringify(state);
            localStorage.setItem('appSnapshot', stateJSON);
            
            const blob = new Blob([stateJSON], {type: "text/plain;charset=utf-8"});
            const url = URL.createObjectURL(blob);

            const link = document.createElement('a');
            link.download = 'state.json';
            link.href = url;
            link.click();

            URL.revokeObjectURL(url);
            
        }

        // <!-- ! Function to load and restore the state
  
        function loadState(saveText) {
            for (let i = 0; i < tableList.length ; i++) {
                d3.selectAll("#mydiv"+i).remove(); 
            }
            
            const stateJSON = saveText;
            if (stateJSON) {
                const state = JSON.parse(stateJSON);

                // Restore the simple state variables
                activateHistograms = state.activateHistograms;
                activateColors = state.activateColors;
                activateBars = state.activateBars;
                activateOpacity = state.activateOpacity;
                activatePriority = state.activatePriority;
                activateScores = state.activateScores;
                activateTOffPriorityMode = state.activateTOffPriorityMode;

                colorMetric = state.colorMetric;
                barsMetric = state.barsMetric;
                opacityMetric = state.opacityMetric;

                priorities = state.priorities;
                idealValues = state.idealValues;
                includedColumns = state.includedColumns;
                categoricalMappings = state.categoricalMappings;
                globalMin = state.globalMin;
                globalMax = state.globalMax;

                minRangeValues = state.minRangeValues;
                maxRangeValues = state.maxRangeValues;

                fileNames = state.fileNames;

                // Restore tableList with placeholders for visual elements
                tableList = state.tableList.map(tableState => {
                    const table = {}; // You would need to recreate the table object structure
                    
                    table.index = tableState.index;
                    table.name = tableState.name;
                    table.keys = tableState.keys;
                    table.data = tableState.data;
                    table.originalData = tableState.originalData;
                    table.numericValues = tableState.numericValues;
                    table.minVal = tableState.minVal;
                    table.maxVal = tableState.maxVal;
                    table.columnMeans = tableState.columnMeans;
                    
                    table.sortOrder = tableState.sortOrder;
                    table.sortColumn = tableState.sortColumn;
                    table.resizeMode = tableState.resizeMode;

                    table.position = tableState.position;

                    return table;
                });



                resetScoreMinMax()
                //update the bindings and re-render the UI
                for (let i = 0; i < tableList.length ; i++) {
                    createDataTable(tableList[i]);
                    createHistograms(tableList[i]);
                    updateScores(tableList[i]);
                }

                for (let i = 0; i < tableList.length ; i++) {
                    updateSort(tableList[i]);
                    updateColors(tableList[i]);
                    updateHistogram(tableList[i]);

                    tableList[i].mydiv.node().style.top = tableList[i].position["top"]
                    tableList[i].mydiv.node().style.left = tableList[i].position["left"]
                    tableList[i].mydiv.node().style.zIndex = tableList[i].position["z-index"]
                }
              
                
                updateFeaturesCheckboxes();
                updateSliderTable();

                

                
            }
        }

        // <!-- ! Function to create the Histograms
        function createHistograms(table) {
            // Check if histograms are activated
            if (!activateHistograms) return;
            
            // Create a new header row for histograms
            table.histogramRow = table.dataThead.append('tr')
                .attr("id", "histogramRow" + table.index) 


            

            table.headers.each(function (columnName, i) {

                // Set up the histogram generator
                var histogram = d3.histogram()
                    .value(function(d) { return d; })
                    .domain([globalMin[columnName],globalMax[columnName] ])
                    

                
                var histograms = [];
                var hist = null;
                // Apply the histogram generator to the datasets to get the bins
                for (let i = 0; i < tableList.length ; i++) {
                    var columnData = tableList[i].data
                        .map(row => row[columnName])
                        .map(val => parseFloat(val))
                        .filter(val => !isNaN(val));
                        
                    histograms.push(histogram(columnData));
                    if(i == table.index){
                        hist = histogram(columnData);
                    }
                    
                }

                concat = [].concat.apply([], histograms);

                // Y axis: scale and draw
                var yScale = d3.scaleLinear()
                    .range([0, 60])
                    .domain( [0, d3.max(concat, function(d) { return d.length; })]); // Use the max bin count as the max domain value
                    
                var columnData = table.data.map(row => row[columnName])
                var isNumeric = !isNaN(columnData[0])
                var cell = table.histogramRow.append('th') // Append a new header cell to the histogram row

                if (isNumeric) {
                    columnData = columnData.map(val => parseFloat(val)).filter(val => !isNaN(val))

                    var svg = cell.append('svg').attr('width', 100).attr('height', 100).attr("id","hist"+i)
           
                    var svgHeight = 100;
                    var histogramHeight = 60;
                    var padding = (svgHeight - histogramHeight) / 2;

                    //Append background base
                    svg.append('rect')
                        .attr('x', 0)
                        .attr('y', padding)
                        .attr('width', 100)
                        .attr('height', 60)
                        .attr('fill', '#f1f1f1') // Add white fill for background
                    // add black boarder
                        .attr('stroke', 'black') // Add black stroke for border

                    svg.selectAll('rect')
                    // Append background rectangles
                    svg.selectAll('rect.background')
                        .data(hist)
                        .enter()
                        .append('rect')
                        .attr('class', 'background')
                        .attr('x', (d, i) => hist.length ? i * 100 / hist.length : 0)
                        .attr('y', padding)
                        .attr('width', hist.length ? 100 / hist.length : 100)
                        .attr('height', 60)
                        
                    
                    
                    
                    
                    svg.selectAll('rect').data(hist)
                    .enter()
                    .append('rect')
                    .attr('class', 'data')
                    .attr('x', (d, i) => hist.length ? i * 100 / hist.length : 0)
                    .attr('y', d => padding + histogramHeight - yScale(d.length))
                    .attr('width', hist.length ? 100 / hist.length : 100)
                    .attr('height', d => yScale(d.length))
                    .attr('stroke', 'black') // Add black stroke for border
                    .attr('stroke-width', 1); // Set the stroke width

                    // Add labels for min and max range
                    var minRange = d3.min(columnData);
                    var maxRange = d3.max(columnData);

                    svg.append('text').attr("class","global-min-range")
                        .attr('x', 0)
                        .attr('y', 10) // Position the label above the bar
                        .attr('font-size', '13px')
                        .text(Number.isInteger(minRange) ? minRange : minRange.toFixed(1));

                    var maxRangeText = svg.append('text').attr("class","global-max-range")
                        .attr('y', 10) // Position the label above the bar
                        .attr('font-size', '13px')
                        .text(Number.isInteger(maxRange) ? maxRange : maxRange.toFixed(1));
                    
                    var textWidth = maxRangeText.node().getBBox().width;

                    maxRangeText.attr('x', 100 - textWidth); // Position the label at the last bar, adjusted for the text width

                    var scale = d3.scaleLinear()
                        .domain([globalMin[columnName], globalMax[columnName]])
                        .range([0, 100]);
                        
                    svg.append('text').attr("class","min-range")
                        .attr('x', scale(table.minVal[columnName])) 
                        .attr('y', histogramHeight+ padding*2) // Position the label below the bar
                        .attr('font-size', '13px')
                        .text(Number.isInteger(table.minVal[columnName]) ? table.minVal[columnName] : table.minVal[columnName].toFixed(1));
                    console.log(columnName ," ", table.maxVal[columnName])
                    svg.append('text').attr("class","max-range")
                        .attr('x', scale(table.maxVal[columnName])) 
                        .attr('y', histogramHeight + padding*2) // Position the label below the bar
                        .attr('font-size', '13px')
                        .text(Number.isInteger(table.maxVal[columnName]) ? table.maxVal[columnName] : table.maxVal[columnName].toFixed(1));
                    
                    if(columnName !== "Score"){      
                        // Drag behavior for the histogram slider
                        const drag = d3.drag()
                        .on("drag", function(d, i) {
                            var x = d3.event.x;
                            var y = d3.event.y;
                            var min = 0;
                            var max = 96;
                            if (x < min) x = min;
                            if (x > max) x = max;
                            d3.select(this).attr("x", x);
                            idealValues[columnName] = (globalMax[columnName] !== globalMin[columnName]) ? (x / 96 * (globalMax[columnName] - globalMin[columnName]) + globalMin[columnName]) : 0;
                            updateSliderTable();
                            resetScoreMinMax();
                            for (let i = 0; i < tableList.length ; i++) {
                                updateScores(tableList[i]);
                            }
                            for (let i= 0 ; i < tableList.length;i++){
                                updateColors(tableList[i]);
                                updateHistogram(tableList[i]);
                                
                            }

                        });
                         
                        svg.append('rect')
                            .attr('class', 'histogram-slider')                
                            .attr('x', 0)
                            .attr('y', padding)
                            .attr('width', 4)
                            .attr('height', 60)
                            .attr('fill', 'blue')
                            .on("mouseover", function(d, i) {
                                d3.select(this).style("cursor", "ew-resize");
                            })
                            .call(drag);
                    }
                    else{
                        //add labels for the score 0 1 
                        svg.append('text').attr("class","Global-min-range")
                            .attr('x', 0)
                            .attr('y', 90) // Position the label above the bar
                            .attr('font-size', '13px')
                            .text(0);
                        
                        svg.append('text').attr("class","Global-max-range")
                            .attr('x', 100 - textWidth) // Position the label at the last bar, adjusted for the text width
                            .attr('y', 90) // Position the label above the bar
                            .attr('font-size', '13px')
                            .text(1);

                    }

                } else {
                    // Step 1: Get all unique categories
                    var allCategories = new Set();
                    tableList.forEach(function(table) {
                        var columnData = table.data.map(row => row[columnName]);
                        columnData.forEach(function(val) {
                            if (isNaN(parseFloat(val))) {  // Check if the value is categorical
                                allCategories.add(val);
                            }
                        });
                    });
                    allCategories = Array.from(allCategories); // Convert to array for indexing
                    

                    // Step 2: Calculate counts for each category in each dataset
                    var categoryCountsPerTable = tableList.map(function(table) {
                        var counts = {};
                        allCategories.forEach(function(cat) { counts[cat] = 0; });  // Initialize counts for each category

                        table.data.forEach(function(row) {
                            table.keys.forEach(function(key) {
                                var val = row[key];
                                if (counts.hasOwnProperty(val)) {
                                    counts[val]++;
                                }
                            });
                        });
                        return counts;
                    });

                    // Step 3: Find the global maximum count for setting the y-scale
                    var categoriesMaxCount = d3.max(categoryCountsPerTable.map(function(counts) {
                        return d3.max(Object.values(counts));
                    }));

                    // Define the y-scale using the global maximum count
                    var yScale = d3.scaleLinear()
                        .range([60, 0])  // Assuming 50px is the height of the histogram
                        .domain([0, categoriesMaxCount]);


                    // Step 4: Draw the histogram

                    // Get the counts for the current dataset and column
                    var currentCounts = categoryCountsPerTable[table.index];

                    var svg = cell.append('svg').attr('width', 100).attr('height', 60).attr("id","hist"+i)
                    
                    // Append background rectangles
                    svg.selectAll('rect.background')
                        .data(hist)
                        .enter()
                        .append('rect')
                        .attr('class', 'background')
                        .attr('x', (d, i) => i * 100/allCategories.length)
                        .attr('y', 0)
                        .attr('width', 100/allCategories.length-2)
                        .attr('height', 60)
                        .attr('fill', 'orange'); // Set the fill color

                    
                    svg.selectAll('rect.data').data(allCategories)
                        .enter()
                        .append('rect')
                        .attr('class', 'data')
                        .attr('x', (d, i) => {
                            
                            return i * 100/allCategories.length;
                        })
                        .attr('y', (d, i) => {
                            
                            return yScale(currentCounts[d] || 0);
                        })
                        .attr('width', 100/allCategories.length-2)
                        .attr('height', (d, i) => {
                            
                            return 60- yScale(currentCounts[d] || 0);
                        })
                        .attr('stroke', 'black') // Add black stroke for border
                        .attr('stroke-width', 1); // Set the stroke width
                }
            })

            updateHistogram(table);

        }
        
       
        // <!-- ! Function to update the histograms
        function updateHistogram(table) {
            //check if the feature is on
            if(!activateHistograms) return;
            
            // get merged data from all tables in fullColumnsData
            var fullColumnsData = {};
            tableList.forEach(function(table) {
                // Iterate over each key in the current table
                table.keys.forEach(function (columnName) {
                    if(!(columnName in fullColumnsData)){
                        fullColumnsData[columnName] = [];
                    }
                    fullColumnsData[columnName] = fullColumnsData[columnName].concat(
                        table.data
                            .map(row => row[columnName])
                            .map(val => parseFloat(val))
                            .filter(val => !isNaN(val))
                    );
                });
            });
            

            table.headers.each(function (columnName, i) {
             
                // Set the ranges
                var x = d3.scaleLinear()
                    .domain([globalMin[columnName],globalMax[columnName] ])  // Data space
                    .range([0, 100]);  // Display space

                // ++++++++++++++++++++===================== HERE

                let thresholds = null;
                let histogram = null;
                if(fullColumnsData[columnName] !== undefined && columnName !== "Score"){
                    
                    switch(histBinFunction){
                        case "sturges":
                            thresholds = d3.thresholdSturges(fullColumnsData[columnName],globalMin[columnName],globalMax[columnName]);
                            break;
                        case "scott":
                            thresholds = d3.thresholdScott(fullColumnsData[columnName],globalMin[columnName],globalMax[columnName]);
                            break;
                        case "freedmanDiaconis":
                            thresholds = d3.thresholdFreedmanDiaconis(fullColumnsData[columnName],globalMin[columnName],globalMax[columnName]);
                            break;
                    }

                    histogram = d3.histogram()
                        .domain([globalMin[columnName],globalMax[columnName]])
                        .thresholds(thresholds);
                   
                }else if (columnName === "Score"){
                    scoreData = table.data.map(row => row[columnName]);

                    // Set thresholds to be between 0 and 1 with ticks of 0.1
                    thresholds = [0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9];
                    
                    histogram = d3.histogram()
                        .domain([0,1])
                        .thresholds(thresholds);
                }
                
                
                    
                
                var histograms = [];
                var hist = null;
                // Apply the histogram generator to the datasets to get the bins
                for (let i = 0; i < tableList.length ; i++) {
                    var columnData = tableList[i].data.map(row => row[columnName]).map(val => parseFloat(val)).filter(val => !isNaN(val));
                    histograms.push(histogram(columnData));
                    if(i == table.index){
                        hist = histogram(columnData);
                        console.log(hist);
                    }
                }

                concat = [].concat.apply([], histograms);

                // Y axis: scale and draw
                var yScale = d3.scaleLinear()
                    .range([0, 60])
                    .domain( [0, d3.max(concat, function(d) { return d.length; })]); // Use the max bin count as the max domain value
                    
                
                var columnData = table.data.map(row => row[columnName]);
                var isNumeric = !isNaN(parseFloat(columnData[0])); // Ensure to parse the first value before checking isNaN

                if (isNumeric || columnName === "Score") {
                    
                    columnData = columnData.map(val => parseFloat(val)).filter(val => !isNaN(val));
            
                    var cell = table.histogramRow.select("#hist"+i);
                        
                    var background = cell.selectAll('rect.background').data(hist); // Bind the bins data to the rectangles
                    
                    
                    var svgHeight = 100;
                    var histogramHeight = 60;
                    var padding = (svgHeight - histogramHeight) / 2;


                    background.enter()
                        .append('rect')
                        .attr('class', 'background')
                        .merge(background) // Merge enter and update selections
                        .attr('x', (d, i) => hist.length ? i * 100 / hist.length : 0)
                        .attr('y', padding)
                        .attr('width', hist.length ? 100 / hist.length : 100) // keep same width as the cell
                        .attr('height', 60);

                    background.exit().remove(); // Remove outdated elements
                        


                    var bars = cell.selectAll('rect.data').data(hist); // Bind the bins data to the rectangles
                    
                    
                    bars.enter()
                        .append('rect')
                        .attr('class', 'data')
                        .merge(bars) // Merge enter and update selections
                        .attr('x', (d, i) => hist.length ? i * 100 / hist.length : 0)
                        .attr('y', d => histogramHeight + padding - yScale(d.length))
                        .attr('width', hist.length ? 100 / hist.length : 100) // keep same width as the cell
                        .attr('height', d => yScale(d.length))
                        .attr('stroke', 'black') // Add black stroke for border
                        .attr('stroke-width', 1); // Set the stroke width

                    bars.exit().remove();
                    

                    // Update the position of the histogram slider
                    if (columnName !== "Score") {
                        histSlider = cell.select('rect.histogram-slider'); 
                        var domainMin = globalMin[columnName]; // minimum value of your data
                        var domainMax = globalMax[columnName]; // maximum value of your data
                        var rangeMin = 0; // minimum value of your output range (likely 0)
                        var rangeMax = 96; // maximum value of your output range (width of your SVG or chart)

                        var xPosition = (domainMax !== domainMin ) ? ((idealValues[columnName] - domainMin) / (domainMax - domainMin)) * (rangeMax - rangeMin) + rangeMin : 0;
                        histSlider.attr('x', xPosition);
                        
                        histSlider.raise();
                        // Add labels for min and max range
                        var minRange = globalMin[columnName];
                        var maxRange = globalMax[columnName];

                        updateRangeText(cell, minRange, maxRange, table.minVal[columnName], table.maxVal[columnName]);
                    }
                    else{
                        // Add labels for min and max range
                        var minRange = globalMin[columnName];
                        var maxRange = globalMax[columnName];

                        updateScoreRangeText(cell, minRange, maxRange, table.minVal[columnName], table.maxVal[columnName]);
                    }



                } else {

                    // Step 1: Get all unique categories
                    var allCategories = new Set();
                    tableList.forEach(function(table) {
                        var columnData = table.data.map(row => row[columnName]);
                        columnData.forEach(function(val) {
                            if (isNaN(parseFloat(val))) {  // Check if the value is categorical
                                allCategories.add(val);
                            }
                        });
                    });
                    allCategories = Array.from(allCategories); // Convert to array for indexing
                    

                    // Step 2: Calculate counts for each category in each dataset
                    var categoryCountsPerTable = tableList.map(function(table) {
                        var counts = {};
                        allCategories.forEach(function(cat) { counts[cat] = 0; });  // Initialize counts for each category

                        table.data.forEach(function(row) {
                            table.keys.forEach(function(key) {
                                var val = row[key];
                                if (counts.hasOwnProperty(val)) {
                                    counts[val]++;
                                }
                            });
                        });
                        return counts;
                    });

                    // Step 3: Find the global maximum count for setting the y-scale
                    var categoriesMaxCount = d3.max(categoryCountsPerTable.map(function(counts) {
                        return d3.max(Object.values(counts));
                    }));

                    // Define the y-scale using the global maximum count
                    var yScale = d3.scaleLinear()
                        .range([60, 0])  // Assuming 50px is the height of the histogram
                        .domain([0, categoriesMaxCount]);


                    // Get the counts for the current dataset and column
                    var currentCounts = categoryCountsPerTable[table.index];
                    
                    var cell = table.histogramRow.select("#hist"+i);
                    
                    var background = cell.selectAll('rect.background').data(allCategories); // Bind category counts to rectangles
                    background.enter()
                        .append('rect')
                        .attr('class', 'background')
                        .merge(background) // Merge enter and update selections
                        .attr('x', (d, i) => i * 100/allCategories.length)
                        .attr('y', 0)
                        .attr('width', 100/allCategories.length-2)
                        .attr('height', 60)
                       
                    
                    var bars = cell.selectAll('rect.data').data(allCategories); // Bind category counts to rectangles

                    bars.enter()
                        .append('rect')
                        .attr('class', 'data')
                        .merge(bars)
                        .attr('x', (d, i) => {
                            
                            return i * 100/allCategories.length;
                        })
                        .attr('y', (d, i) => {
                            
                            return yScale(currentCounts[d] || 0);
                        })
                        .attr('width', 100/allCategories.length-2)
                        .attr('height', (d, i) => {
                            
                            return 60- yScale(currentCounts[d] || 0);
                        })
                        .attr('stroke', 'black') // Add black stroke for border
                        .attr('stroke-width', 1); // Set the stroke width

                    bars.exit().remove();x
                }
            });
            updateHistogramColors(table); // Ensure this function exists and is defined to update colors as necessary
        }

        // <!-- ! Function to update the score range text in the histogram
        function updateScoreRangeText(cell , minRange, maxRange, localminRange, localmaxRange){
            // GLOBAL MIN AND MAX RANGE
            var globalMinRangeText = cell.select('text.global-min-range');
            var globalMaxRangeText = cell.select('text.global-max-range');

            globalMinRangeText.text(Number.isInteger(minRange) ? minRange : Math.floor(minRange*10) /10 );
            globalMaxRangeText.text(Number.isInteger(maxRange) ? maxRange : Math.floor(maxRange*10) /10 );

            // Adjust the position of maxRangeText based on its width
            var textWidth = globalMaxRangeText.node().getBBox().width;
            
            var xMinPos = Math.floor(minRange * 100);
            var xMaxPos = Math.floor(maxRange * 100);

            //Handle border cases
            xMinPos = (xMinPos + textWidth > 100) ? 100 : xMinPos;
            xMinPos = (xMinPos < 0) ? 0 : xMinPos;
            
            xMaxPos = (xMaxPos + textWidth > 100) ? 100 : xMaxPos;
            xMaxPos = (xMaxPos < 0) ? 0 : xMaxPos;
            
   
            globalMinRangeText.attr('x', xMinPos );
            globalMaxRangeText.attr('x', xMaxPos );
            
            globalMinRangeText.raise();
            globalMaxRangeText.raise();

            // LOCAL MIN AND MAX RANGE
            var minRangeText = cell.select('text.min-range');
            var maxRangeText = cell.select('text.max-range');

            minRangeText.text(Number.isInteger(localminRange) ? localminRange : Math.floor(localminRange*10) /10 );
            maxRangeText.text(Number.isInteger(localmaxRange) ? localmaxRange : Math.floor(localmaxRange*10) /10 );

            //Adjust the position of minRangeText based on its width
            var textWidth = minRangeText.node().getBBox().width;
            var scale = d3.scaleLinear()
                .domain([minRange, maxRange])
                .range([0, 100]);
            
            var xMin = scale(localminRange);
            var xMax = scale(localmaxRange);

            // Handle border cases
            xMin = ((xMin + textWidth) > 100) ? (100 - textWidth) : xMin;
            xMin = (xMin < 0) ? 0 : xMin;

            xMax = ((xMax + textWidth) > 100) ? (100 - textWidth) : xMax;
            xMax = (xMax < 0) ? 0 : xMax;

            maxRangeText.attr('x', xMax);
            minRangeText.attr('x', xMin);

            minRangeText.raise();
            maxRangeText.raise();
        }

        // <!-- ! Function to update the range text in the histogram
        function updateRangeText(cell, minRange, maxRange, localminRange, localmaxRange) {
            // GLOBAL MIN AND MAX RANGE
            var globalMinRangeText = cell.select('text.global-min-range');
            var globalMaxRangeText = cell.select('text.global-max-range');

            globalMinRangeText.text(Number.isInteger(minRange) ? minRange : minRange.toFixed(1));
            globalMaxRangeText.text(Number.isInteger(maxRange) ? maxRange : maxRange.toFixed(1));

            // Adjust the position of globalMaxRangeText based on its width
            var textWidth = globalMaxRangeText.node().getBBox().width;
            globalMaxRangeText.attr('x', 100 - textWidth);
            
            globalMinRangeText.raise();
            globalMaxRangeText.raise();

            var minRangeText = cell.select('text.min-range');
            var maxRangeText = cell.select('text.max-range');


            // LOCAL MIN AND MAX RANGE

            minRangeText.text(Number.isInteger(localminRange) ? localminRange : localminRange.toFixed(1));
            maxRangeText.text(Number.isInteger(localmaxRange) ? localmaxRange : localmaxRange.toFixed(1));

            //Adjust the position of minRangeText based on its width
            var textWidth = minRangeText.node().getBBox().width;
            var scale = d3.scaleLinear()
                .domain([minRange, maxRange])
                .range([0, 100]);
            
            var xMin = scale(localminRange);
            var xMax = scale(localmaxRange);

            // Handle border cases
            xMin = ((xMin + textWidth) > 100) ? (100 - textWidth) : xMin;
            xMin = (xMin < 0) ? 0 : xMin;            
            
            xMax = ((xMax + textWidth) > 100) ? (100 - textWidth) : xMax;
            xMax = (xMax < 0) ? 0 : xMax;

            maxRangeText.attr('x', xMax);
            minRangeText.attr('x', xMin);




            minRangeText.raise();
            maxRangeText.raise();
        }

        // <!-- ! Function to update the colors of the histograms
        function updateHistogramColors(table) {

            if(!activateHistograms) return;

            table.headers.each(function (columnName, i) {
         
                var columnData = table.data.map(row => row[columnName]);
                var isNumeric = !isNaN(columnData[0]);

                if (isNumeric) {
                    var cell = table.histogramRow.select("#hist" + i);

                    var bars = cell.selectAll('rect.data') // Using a key function for proper data join

                    const colorScale = d => {
                        if(activateColors){
                            var midpoint = (d.x0 + d.x1) / 2;
                            var distance, maxDistance;

                            if (columnName === "Score") {
                                distance = Math.abs(midpoint - 1);
                                maxDistance = 1;
                                var t = distance;
                                return t < 0.5 ? d3.interpolate('green', 'white')(t * 2) : d3.interpolate('white', 'red')((t - 0.5) * 2);
                            } else {
                                distance = Math.abs(midpoint - idealValues[columnName]);
                                maxDistance = globalMax[columnName] - globalMin[columnName];
                                scaledDistance = maxDistance !== 0 ? distance / maxDistance : 1;

                                if (scaledDistance <= 0.5) {
                                    // Interpolate between 'green' and 'white' for the first half of the range
                                    return d3.interpolate('green', 'white')(scaledDistance * 2);
                                } else {
                                    // Interpolate between 'white' and 'red' for the second half of the range
                                    return d3.interpolate('white', 'red')((scaledDistance - 0.5) * 2);
                                }
                            }
                        }
                        else{
                            return "white";
                        }

                        
                        
                        
                    };

                    var background = cell.selectAll('rect.background');
                    background.attr('fill', colorScale)
                        .style('opacity', 0.15);

                    bars.attr('fill', colorScale)
                    .attr('stroke', 'black') // Add black stroke for border
                    .attr('stroke-width', 1); // Set the stroke width
                
                }
                else {
                    
                    var cell = table.histogramRow.select("#hist"+i);
                    var bars = cell.selectAll('rect.data');
                    

                    // Step 1: Get all unique categories
                    var allCategories = new Set();
                    tableList.forEach(function(table) {
                        var columnData = table.data.map(row => row[columnName]);
                        columnData.forEach(function(val) {
                            if (isNaN(parseFloat(val))) {  // Check if the value is categorical
                                allCategories.add(val);
                            }
                        });
                    });
                    allCategories = Array.from(allCategories); // Convert to array for indexing


                    var colorScale = cat => {
                        if(activateColors){
                            var distance = Math.abs(categoricalMappings[columnName][cat] - 100);
                            var maxDistance = 200;
                            var scaledDistance = maxDistance !== 0 ? distance / maxDistance : 1;

                            if (scaledDistance <= 0.5) {
                                // Interpolate between 'green' and 'white' for the first half of the range
                                return d3.interpolate('green', 'white')(scaledDistance * 2);
                            } else {
                                // Interpolate between 'white' and 'red' for the second half of the range
                                return d3.interpolate('white', 'red')((scaledDistance - 0.5) * 2);
                            }
                        }
                        else{
                            return "white";
                        }

                    };

                    var background = cell.selectAll('rect.background');
                    background.attr('fill', colorScale)
                        .style('opacity', 0.15);

                    bars.attr('fill', colorScale)
                        .attr('stroke', 'black') // Add black stroke for border
                        .attr('stroke-width', 1); // Set the stroke width
                }
                // Add else if condition here for categorical data if needed
            });
        }

        // <!-- ! Function to update the checkboxes of the slider table
        function updateFeaturesCheckboxes() {
            // Update activateHistograms checkbox and run its action
            d3.select("#activateHistograms").property("checked", activateHistograms);
            if (!activateHistograms) {   
                for (let j = 0; j < tableList.length; j++) {
                    d3.selectAll("#histogramRow" + j).remove();
                }
            }

            // Update activatePriority checkbox and run its action
            d3.select("#activatePriority").property("checked", activatePriority);
            if (activatePriority) {
                for (let j = 0; j < tableList.length; j++) {
                    tableList[j].rows.selectAll("td").selectAll(".progress-bar").style("width", function(d) {
                        if (includedColumns[d.column] && d.column !== "Score") {
                            
                       
                            const coeff = Math.abs(d.value - idealValues[d.column]) * priorities[d.column] ;
                            const prioritySum = Object.values(priorities).reduce((prev,curr) => curr+prev, 0);
                            const result = coeff;

                            return result+"%" ;
                        } else if (d.column === "Score") {
                            return '100%';
                        } else {
                            return '50%';
                        }
                    });
                }
            } else {
                for (let j = 0; j < tableList.length; j++) {
                    tableList[j].rows.selectAll("td").style("opacity", 1);
                }
            }

            // Update activateTOffPriorityMode checkbox and run its action
            d3.select("#activateTOffPriorityMode").property("checked", activateTOffPriorityMode);


            // Update activateScores checkbox and run its action
            d3.select("#activateScores").property("checked", activateScores);
            resetScoreMinMax();
            for (let j = 0; j < tableList.length; j++) {
                updateScores(tableList[j]);
            }
            for (let j = 0; j < tableList.length; j++) {
                updateHistogram(tableList[j]);
            }

            // Update activateColors checkbox and run its action
            d3.select("#activateColors").property("checked", activateColors);
            for (let j = 0; j < tableList.length; j++) {
                updateColors(tableList[j]);
                updateHistogramColors(tableList[j]);
            }

            // Update the color Metric dropdown
            d3.select("#colorMetric").property("value", colorMetric);

            // update activatebars checkbox and run its action
            d3.select("#activateBars").property("checked", activateBars);
            for (let j = 0; j < tableList.length; j++) {
                
            }

            // Update the bars metric dropdown
            d3.select("#barsMetric").property("value", barsMetric);
        
            //activate opacity
            d3.select("#activateOpacity").property("checked", activateOpacity);

            // Update the opacity metric dropdown
            d3.select("#opacityMetric").property("value", opacityMetric);

            // Update histBinFunction dropdown
            d3.select("#histBinFunction").property("value", histBinFunction);            
            
        }

        // <!-- ! Function to create the slider table
        function createSliderTable(){
            // Creating the slider table and its header and body sections
            // This table allows users to adjust the "Ideal Value" and "Priority" for each column in the data
            window.sliderTable = d3.select("body").append("table");
            var sliderThead = sliderTable.append("thead");
            window.sliderTbody = sliderTable.append("tbody");

            // Adding headers to the slider table
            // If a column is categorical, a "Map Score" button is added
            // This button allows users to map categorical values to numeric scores
            var sliderHeaders = sliderThead.append("tr")
                .selectAll("th")
                .data(tableList[0].keys)
                .enter()
                .append("th").attr("class", "sliderHeader")
                .text(function(d) {
                    return d;
                })
                .each(function(d, i) {

                    if (isNaN(tableList[0].data[0][d])) {  // Check if the column is categorical
                        var categories = [...new Set(tableList.map(table => table.data.map(row => row[d])).flat())];

                        if (!window.categoricalMappings.hasOwnProperty(d)) {
                            window.categoricalMappings[d] = {};
                        }

                        categories.forEach(cat => window.categoricalMappings[d][cat] = 0); // Initialize all categories to 0
                        
                        
                        d3.select(this).append("button")
                            .text("Map Score")
                            .on("click", function(d, i) {
                                // Creating the mapping table when "Map Score" is clicked
                                createMappingTable(d, tableList);
                            });
                    }
                });

            

                
                
            // Adding checkboxes to enable/disable columns for score calculation
            // Users can choose which columns to include in the score calculation by checking/unchecking these boxes
            checkboxes = sliderHeaders.append("input")
                .attr("type", "checkbox")
                .attr("id", function (d) { return "checkbox" + d; })
                .attr("name", function (d) { return d; })
                .property("checked", false)
                .on("change", function(d, i) { 
                    includedColumns[d] = d3.select(this).property("checked")
                    updateColumnState(tableList);
                    for (let j= 0 ; j < tableList.length;j++){
                        updateHistogram(tableList[j]);
                    }
                });

            // Adding priority sliders and displaying the current priority
            // Users can adjust the priority (importance) of each column using these sliders
            var priorityRow = sliderTbody.append("tr");
            priorityRow.selectAll("td")
                .data(d3.keys(tableList[0].data[0]))
                .enter()
                .append("td")
                .each(function (d, i) {
                    // Initializing priorities and includedColumns
                    priorities[d] =  50;
                    includedColumns[d] = false;

                    // Adding a slider to adjust the priority
                    let updateScheduled = false;
                    d3.select(this).append("input")
                        .attr("type", "range")
                        .attr("id", "prioritySlider"+d)
                        .attr("min", 1)
                        .attr("max", 100)
                        .attr("value", priorities[d])
                        .on("input", function () {
                            // Updating displayed priority
                            this.nextSibling.textContent = this.value;
                            priorities[d] = parseInt(this.value);

                            if (!updateScheduled) {
                                updateScheduled = true;

                                // Updating scores and colors when the slider is adjusted
                                // Using requestAnimationFrame to avoid updating the scores and colors too frequently
                                requestAnimationFrame(() => {
                                    updateScheduled = false;

                                    if(activateTOffPriorityMode){
                                        updateTOffPriorities(d);
                                        updateSliderTable();
                                    }

                                    resetScoreMinMax();
                                    for (let i = 0; i < tableList.length ; i++) {
                                        updateScores(tableList[i]);
                                    }
                                    for (let i= 0 ; i < tableList.length;i++){
                                        updateColors(tableList[i]);
                                        updateHistogram(tableList[i]);
                                    }
                                });
                            }
                        });
                    // Displaying the current priority
                    d3.select(this).append("span")
                        .text(restrictedMode ? Math.floor(priorities[d]).toString() : priorities[d].toFixed(2));
                });
            
            

            // Adding sliders for adjusting ideal values and displaying the current ideal value
            // Users can adjust the ideal (best) value for each column using these sliders
            var idealValueRow = sliderTbody.append("tr");
            idealValueRow.selectAll("td")
                .data(d3.keys(tableList[0].data[0]))
                .enter()
                .append("td")
                .each(function (d) {
                    // Extracting numeric values from the column
                    var minVal = globalMin[d];
                    var maxVal = globalMax[d];

                    // If the column contains numeric data, add a slider to adjust the ideal value
                    if (minVal !== undefined && maxVal !== undefined) {
                        idealValues[d] = minVal;

                        let updateScheduled = false;
                        // Adding a slider to adjust the ideal value
                        d3.select(this).append("input")
                            .attr("type", "range")
                            .attr("id", "IdealSlider" + d)
                            .attr("min", minVal)
                            .attr("max", maxVal)
                            .attr("value", idealValues[d])
                            .on("input", function () {
                                
                                // Updating displayed ideal value 
                                // and updating scores and colors when the slider is adjusted
                                // Using requestAnimationFrame to avoid updating the scores and colors too frequently

                                this.nextSibling.textContent = this.value;
                                idealValues[d] = parseFloat(this.value);

                                if (!updateScheduled) {
                                    updateScheduled = true;

                                    requestAnimationFrame(() => {
                                        updateScheduled = false;



                                        resetScoreMinMax();
                                        for (let i = 0; i < tableList.length ; i++) {
                                            updateScores(tableList[i]);
                                        }
                                        for (let i= 0 ; i < tableList.length;i++){
                                            updateColors(tableList[i]);
                                            updateHistogram(tableList[i]);
                                        }
                                    });
                                }
                            });
                            
                        // Displaying the current ideal value
                        d3.select(this).append("span")
                            .text(restrictedMode ? Math.floor(idealValues[d]).toString() : idealValues[d].toFixed(2));
                    }
                });

            

            
            // Insert the 'th' with '-' at the beginning
            sliderThead.select("tr").insert("th", ":first-child").text("-");
            // Insert the 'td' with 'Priority' at the beginning
            priorityRow.insert("td", ":first-child").text("Priority");
            // Insert the 'td' with 'Ideal value' at the beginning
            idealValueRow.insert("td", ":first-child").text("Ideal value");
           
                
        }

        /*
        // Function to filterData the data of the columns
        function filterData(data, lowerLimits, upperLimits) {
            // Filter the data based on the provided lower and upper limits
            return data.filter(function(row) {
                for (var column in lowerLimits) {
                    if (row[column] < lowerLimits[column] || row[column] > upperLimits[column]) {
                        return false;
                    }
                }
                return true;
            });
        }
        */

        //<!-- ! Function to update the Sliders in the slider table mostly the priority sliders
        function updateSliderTable() {
            // Update checkboxes based on the includedColumns object
            // Update the checkboxes for each column
            for (const column in includedColumns) {
                d3.select(`#checkbox${column}`).property("checked", includedColumns[column]);
            }

            // Update priority sliders and the displayed priority values
            for (const column in priorities) {
                const slider = d3.select(`#prioritySlider${column}`);
                console.log("updating slider ", `#prioritySlider${column}`, slider);
                if (!slider.empty()) {
                   
                    slider.property("value", priorities[column]);
                    slider.node().nextSibling.textContent = restrictedMode ? Math.floor(priorities[column]) : priorities[column].toFixed(2);
                }
            }

            // Update ideal value sliders and the displayed ideal values
            for (const column in idealValues) {
                const slider = d3.select(`#IdealSlider${column}`);
                if (!slider.empty()) {
                    
                    slider.property("value", idealValues[column]);
                    slider.node().nextSibling.textContent = restrictedMode ? Math.floor(idealValues[column]) : idealValues[column].toFixed(2);
                }
            }
        }

        //<!-- ! Function to normalize the priority sliders on a total of 100
        function updateTOffPriorities(columnName) {
            // Update priorities based on the includedColumns object
            if(includedColumns[columnName]){
             
                var remainingPourcentage = 100 - priorities[columnName];
                
                var partialSum  = Object.keys(priorities)
                        .filter(key => includedColumns[key])
                        .reduce((total, key) => total + Number(priorities[key]), 0);
                var partialSum = partialSum - priorities[columnName];


                for (const column in includedColumns) {
                    if(includedColumns[column] && column !== columnName){
    
                        partSize = partialSum !== 0 ? priorities[column] / partialSum : 0;
                        if(remainingPourcentage < 0){
                            priorities[column] = partSize * remainingPourcentage;
                        }else if(remainingPourcentage > 0){
                            priorities[column] = partSize * remainingPourcentage;
                        }
                    }
                } 
            }
            var totalsum  = Object.keys(priorities)
                        .filter(key => includedColumns[key])
                        .reduce((total, key) => total + Number(priorities[key]), 0);

 
        }

        //<!-- ! Helper function to check if two objects are equal
        function isEqual(objA, objB) {
            const objAKeys = Object.keys(objA);
            const objBKeys = Object.keys(objB);
            if (objAKeys.length !== objBKeys.length) return false;
            for (let key of objAKeys) {
                if (objA[key] !== objB[key]) return false;
            }
            return true;
        }

        //<!-- ! Helper function to get default categorical mapping
        function defaultCategoricalMapping(column) {
            const categories = [...new Set(tableList[0].data.map(row => row[column]))]; // Extract all unique categories from the column
            const mapping = {};
            categories.forEach(cat => mapping[cat] = 0); // Initialize all categories to 0
            return mapping;
        }


        //<!-- ! Function to create a mapping table for categorical values
        function createMappingTable(column, tableList) {
            // Removing any existing mapping table
            d3.select("#mappingTable").remove();

            // Creating a new mapping table
            var mappingTable = d3.select("body").append("table").attr("id", "mappingTable"),
                mappingThead = mappingTable.append("thead"),
                mappingTbody = mappingTable.append("tbody");

            
            // Getting unique categorical values
            // Concatenate the column from all datasets and create a Set to find unique values
            var allValues = tableList.reduce((acc, table) => acc.concat(table.data.map(row => row[column])), []);
            var uniqueValues = [...new Set(allValues)];

            // Creating header row
            mappingThead.append("tr").selectAll("th")
                .data([column, "Score"])
                .enter()
                .append("th")
                .text(d => d);

            // Creating a row for each unique value
            var rows = mappingTbody.selectAll("tr")
                .data(uniqueValues)
                .enter()
                .append("tr")
               

            // Creating a cell for the categorical value
            rows.append("td")
                .text(d => d);

            // Creating a cell with a slider for setting the score
            rows.append("td")
                .each(function (value) {
                    d3.select(this).append("input")
                        .attr("type", "range")
                        .attr("id", column + "mappingSlider")
                        .attr("min", -100)
                        .attr("max", 100)
                        .attr("value", categoricalMappings[column] && categoricalMappings[column][value] !== undefined ? categoricalMappings[column][value] : 0)
                        .on("input", function () {
                            // Updating the mapping and scores when the slider is adjusted
                            if (!categoricalMappings[column]) {
                                categoricalMappings[column] = {};
                            }
                            categoricalMappings[column][value] = +this.value;
                            this.nextSibling.textContent = this.value;
                            resetScoreMinMax();
                            for (let i = 0; i < tableList.length; i++) {
                                updateScores(tableList[i]);
                            }
                            for (let i= 0 ; i < tableList.length;i++){
                                updateHistogram(tableList[i]);
                            }
                            
                        });
                    // Displaying the current mapped score
                    d3.select(this).append("span")
                        .text(categoricalMappings[column] && categoricalMappings[column][value] !== undefined ? categoricalMappings[column][value] : 0);
                });
        }

        //<!-- ! Collection of functions to resize the table div
        function doResize(e, table) {

            
            var scrollSpeed = 10;  // Adjust this value to change the scroll speed
            var edgeDistance = 100;  // Adjust this value to change how close the mouse needs to be to the edge to start scrolling

            // Scroll up
            if (e.clientY < edgeDistance) {
                window.scrollBy(0, -scrollSpeed);
            }

            // Scroll down
            if (window.innerHeight - e.clientY < edgeDistance) {
                window.scrollBy(0, scrollSpeed);
            }

            // Scroll left
            if (e.clientX < edgeDistance) {
                window.scrollBy(-scrollSpeed, 0);
            }

            // Scroll right
            if (window.innerWidth - e.clientX < edgeDistance) {
                window.scrollBy(scrollSpeed, 0);
            }
        
            // Temporarily set the dimensions of dataTable to auto to measure its natural dimensions
            table.dataTable.style('width', 'auto').style('height', 'auto');
            
            // Compute the height for dataTable based on mydiv's height and mydivheader's height
            var mydivHeaderHeight = table.mydivheader.node().offsetHeight;
            var mydivHeight = table.mydiv.node().offsetHeight;
            var tableHeight = mydivHeight - mydivHeaderHeight;
            
            // Get the natural dimensions of dataTable
            var naturalWidth = table.dataTable.node().scrollWidth;
            var naturalHeight = table.dataTable.node().scrollHeight;
            
            // Reset the dimensions of dataTable to 100%
            table.dataTable.style('width', '100%').style('height', '100%');
    
            
            // Calculate how much the mouse has moved
            var width = e.clientX - table.mydiv.node().offsetLeft + window.scrollX;
            var height= e.clientY - table.mydiv.node().offsetTop + window.scrollY;
            
            if (table.resizeMode === 'both') {
                // Ensure the new dimensions are not less than the natural dimensions of dataTable
                width = Math.max(width, naturalWidth,200);
                height = Math.max(height, naturalHeight+mydivHeaderHeight);
                
                // Update the dimensions of mydiv
                table.mydiv
                    .style('width', width + 'px')
                    .style('height', height + 'px')
                    

                table.dataTable
                    .style('width', '100%')  // Setting the width to 100% of mydiv
                    .style('height', tableHeight + 'px');  // Setting the height to the computed height
                
                table.scrolldiv
                    .style('width', '100%')
                    .style('height', tableHeight + 'px');

            } else if (table.resizeMode === 'free') {
                // Ensure the new dimensions are not less than the natural dimensions of dataTable
                width = Math.max(width,200);
                height = Math.max(height+mydivHeaderHeight, mydivHeaderHeight);

                // Update the dimensions of mydiv
                table.mydiv
                    .style('width', width + 'px')
                    .style('height', height + 'px')
                    

                table.dataTable
                    .style('width', '100%')  // Setting the width to 100% of mydiv
                    .style('height', tableHeight + 'px');  // Setting the height to the computed height
                
                table.scrolldiv
                    .style('width', '100%')
                    .style('height', tableHeight + 'px');
                    
            } else if (table.resizeMode === 'hide') {
                // Ensure the new dimensions are not less than the natural dimensions of dataTable
                width = Math.max(width, naturalWidth,200);
                
                // Update the dimensions of mydiv
                table.mydiv
                    .style('width', width + 'px')
                    .style('height', mydivHeaderHeight + 'px');

                table.dataTable
                    .style('display', 'none');  // Hide the table
                
                table.scrolldiv
                    .style('width', '100%')
                    .style('height', 0 + 'px');
            }
        }

        function updateResize(table) {
            // Temporarily set the dimensions of dataTable to auto to measure its natural dimensions
            table.dataTable.style('width', 'auto').style('height', 'auto');
            
            // Compute the height for dataTable based on mydiv's height and mydivheader's height
            var mydivHeaderHeight = table.mydivheader.node().offsetHeight;
            var mydivHeight = table.mydiv.node().offsetHeight;
            var tableHeight = mydivHeight - mydivHeaderHeight;
            
            // Get the natural dimensions of dataTable
            var naturalWidth = table.dataTable.node().scrollWidth;
            var naturalHeight = table.dataTable.node().scrollHeight;
            
            // Reset the dimensions of dataTable to 100%
            table.dataTable.style('width', '100%').style('height', '100%');
            
            // Calculate how much the mouse has moved
            var width = table.mydiv.node().offsetWidth;
            var height = 200;

            if (table.resizeMode === 'both') {
                // Ensure the new dimensions are not less than the natural dimensions of dataTable
                width = Math.max(width, naturalWidth,200);
                height = Math.max(height, naturalHeight+mydivHeaderHeight);
                
                // Update the dimensions of mydiv
                table.mydiv
                    .style('width', width + 'px')
                    .style('height', height + 'px')
                    

                table.dataTable
                    .style('width', '100%')  // Setting the width to 100% of mydiv
                    .style('height', tableHeight + 'px');  // Setting the height to the computed height

                table.scrolldiv
                    .style('width', '100%')
                    .style('height', tableHeight + 'px');

            } else if (table.resizeMode === 'free') {
                // Ensure the new dimensions are not less than the natural dimensions of dataTable
                width = Math.max(width,200);
                height = Math.max(height+mydivHeaderHeight, mydivHeaderHeight);

                // Update the dimensions of mydiv
                table.mydiv
                    .style('width', width + 'px')
                    .style('height', height + 'px')
                    

                table.dataTable
                    .style('width', '100%')  // Setting the width to 100% of mydiv
                    .style('height', tableHeight + 'px');  // Setting the height to the computed height
                
                table.scrolldiv
                    .style('width', '100%')
                    .style('height', tableHeight + 'px');
                    
            } else if (table.resizeMode === 'hide') {
                // Ensure the new dimensions are not less than the natural dimensions of dataTable
                width = Math.max(width, naturalWidth,200);
                
                // Update the dimensions of mydiv
                table.mydiv
                    .style('width', width + 'px')
                    .style('height', mydivHeaderHeight + 'px');

                table.dataTable
                    .style('display', 'none');  // Hide the table

                table.scrolldiv
                    .style('width', '100%')
                    .style('height', 0 + 'px');
            }
        }

        function stopResize() {
            // Remove the event listeners, stopping the resizing
            document.documentElement.removeEventListener('mousemove', resizeFunction, false);
            document.documentElement.removeEventListener('mouseup', stopResize, false);
        }

        //<!-- ! Function to enable dragging of the table div
        function dragElement(elmnt, headerId, table) {
            
            var pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
            var header = document.getElementById(headerId);
            if (header) {
                header.onmousedown = dragMouseDown.bind(this, table);
            } else {
                elmnt.onmousedown = dragMouseDown.bind(this, table);
            }
            function dragMouseDown(table, e) {

                e = e || window.event;
                e.preventDefault();
                pos3 = e.clientX;
                pos4 = e.clientY;
                document.onmouseup = closeDragElement;
                // Bind table to the elementDrag function
                document.onmousemove = elementDrag.bind(this, table);
                // Bring elmnt to the front
                var highestZIndex = Math.max(...Array.from(document.querySelectorAll('*')).map(elem => parseFloat(getComputedStyle(elem).zIndex) || 0));
                elmnt.style.zIndex = highestZIndex + 1;
                table.position["z-index"] = highestZIndex + 1;
            }

            function elementDrag(table, e) {
            
                e = e || window.event;
                e.preventDefault();
                pos1 = pos3 - e.clientX;
                pos2 = pos4 - e.clientY;
                pos3 = e.clientX;
                pos4 = e.clientY;
                elmnt.style.top = (elmnt.offsetTop - pos2) + "px";
                elmnt.style.left = (elmnt.offsetLeft - pos1) + "px";
                
                
                // Update the position of the table
                table.position["top"] = (elmnt.offsetTop - pos2) + "px";
                table.position["left"] = (elmnt.offsetLeft - pos1) + "px";
              
                
                
            }

            function closeDragElement() {
                document.onmouseup = null;
                document.onmousemove = null;
            }
        }

        //<!-- ! Function to disable dragging of the table div
        function disableDragElement(elmnt, headerId) {
            var header = document.getElementById(headerId);
            if (header) {
                header.onmousedown = null;
            } else {
                elmnt.onmousedown = null;
            }
        }

        //<!-- ! Function to create a data table
        function createDataTable(table){
            
            table.mydiv = d3.select("body").append("div").attr("id", "mydiv"+table.index)
                
                .attr("id", "mydiv"+table.index)
                .style("position", "absolute")
                .style("z-index", "9")
                .style("background-color", "#f1f1f1")
                .style("border", "1px solid #d3d3d3")
                .style("text-align", "center")
                .style("top", table.position["top"])
                .style("left", table.position["left"]);

            // Create a header div within 'mydiv' for dragging.
            table.mydivheader = table.mydiv.append("div").attr("id", "mydivheader"+table.index)
                .attr("id", "mydivheader"+table.index)
                .style("cursor", "move")
                .style("background-color", "#2196F3")
                .style("color", "#fff")
                .text(table.name);
            
            table.mydivheader.append("button")
                .text("ðŸ—•")
                .attr("id", "hide-table"+table.index)
                .on("click", function() {
                    table.resizeMode = 'hide';
                    table.dataTable.style('display', 'none');
                    updateResize(table);updateResize(table);
                    
                });

            table.mydivheader.append("button")
                .text("â‡²")
                .attr("id", "resize-free"+table.index)
                .on("click", function() {
                    table.resizeMode = 'free';
                    table.dataTable.style('display', null).style('overflow', 'auto');
                    updateResize(table);updateResize(table);
                    
                });

            table.mydivheader.append("button")
                .text("â›¶")
                .attr("id", "resize-both"+table.index)
                .classed("active", true)
                .on("click", function() { // Set up event listeners for the buttons
                    table.resizeMode = 'both';
                    table.dataTable.style('display', null).style('overflow', null);
                    updateResize(table);updateResize(table);
                    

                });


                table.mydivheader.append("button")
                    .text(table.pin ? "ðŸ“" : "ðŸ“Œ") // If table is pinned, show unlock icon, else show pin icon
                    .style("float", "right")
                    .attr("id", "pin-table"+table.index)
                    .on("click", function() {
                        // Disable dragging
                        table.pin = !table.pin;
                        if (!table.pin) {
                            d3.select(this).text("ðŸ“Œ");
                            table.mydivheader.style("cursor", "move");
                            table.mydivheader.style("background-color", "#2196F3");     //grey

                            dragElement(table.mydiv.node(), "mydivheader"+table.index, table );
                            table.resizer.on('mousedown', function() {
                                d3.event.preventDefault();
                                startX = d3.event.clientX;
                                startY = d3.event.clientY;
                                startWidth = parseInt(table.mydiv.style('width'), 10);
                                startHeight = parseInt(table.mydiv.style('height'), 10);

                                resizeFunction = function(e) { doResize(e,table);}

                                // When the mouse is moved while the mouse button is down, call the resizing function
                                document.documentElement.addEventListener('mousemove', resizeFunction, false);

                                // When the mouse button is released, stop resizing
                                document.documentElement.addEventListener('mouseup', stopResize, false);
                            });
                            table.resizer.style('cursor', 'se-resize');
                            
                        } else {
                            d3.select(this).text("ðŸ“");
                            table.mydivheader.style("background-color", "#808080");
                            table.mydivheader.style("cursor", "default");
                            disableDragElement(table.mydiv.node(), "mydivheader"+table.index);
                            table.resizer.on('mousedown', null)
                            .style('cursor', 'default');

                        }
                    });
            
            
            // Now we'll add a resizer div to mydiv
            table.resizer = table.mydiv.append('div').attr("id", "resizer"+table.index)
                .style('width', '10px')
                .style('height', '10px')
                .style('background-color', 'black')
                .style('position', 'absolute')
                .style('right', '0')
                .style('bottom', '0')
                .style('cursor', 'se-resize');

            // Variables to hold the starting mouse position
            var startX, startY, startWidth, startHeight;

            // Mouse down event on the resizer
            table.resizer.on('mousedown', function() {
                d3.event.preventDefault();
                startX = d3.event.clientX;
                startY = d3.event.clientY;
                startWidth = parseInt(table.mydiv.style('width'), 10);
                startHeight = parseInt(table.mydiv.style('height'), 10);

                resizeFunction = function(e) { doResize(e,table);}

                // When the mouse is moved while the mouse button is down, call the resizing function
                document.documentElement.addEventListener('mousemove', resizeFunction, false);

                // When the mouse button is released, stop resizing
                document.documentElement.addEventListener('mouseup', stopResize, false);
            });

            // Creating the data table and its header and body sections
            // This table displays the data and calculated scores
            table.scrolldiv = table.mydiv.append("div").attr("id", "dataTableScroll"+table.index)
                .style("overflow", "auto")
                .style("height", "100%")
                .style("width", "100%")
            table.dataTable = table.scrolldiv
                .append("table")
                .attr("id", "dataTable"+table.index)
                .attr('class',"mapping-table")
                .style('grid-template-columns', 'repeat(' + Object.values(priorities).length + ',1fr) 1fr')

            table.dataThead = table.dataTable.append("thead").attr("id", "dataThead"+table.index),
            table.dataTbody = table.dataTable.append("tbody").attr("id", "dataTbody"+table.index);

            // Call the dragElement function with your draggable div
            dragElement(table.mydiv.node(), "mydivheader"+table.index, table);

            // Adding headers to the data table and enabling sorting
            // Users can click on a header to sort the table by that column
            var databind = null
            if (!d3.keys(table.data[0]).includes("Score") ){
                databind = d3.keys(table.data[0]).concat(["Score"])
            }else{
                databind = d3.keys(table.data[0])
            }

            table.headers = table.dataThead.append("tr")
                .selectAll("th")
                .data(databind)  // Adding an additional "Score" column
                .enter()
                .append("th")
                .text(function (d) { return d; })
                .on("click", function (d) {
                    // Sorting the table when a header is clicked, unless the click was used to stop event propagation
                    if (!d3.event.defaultPrevented) {
                        sortTable(d, this ,table);
                    }
                    d3.event.preventDefault();
                });
            
            
            table.headers.attr("class", "headers"+table.index )

            // Adding rows to the data table
            table.rows = table.dataTbody.selectAll("tr")
                .data(table.data)
                .enter()
                .append("tr")
                .attr("class", "rows" + table.index);

            // Defining a color scale to represent the distance from the ideal value
            // Values close to the ideal value are green, values far from the ideal value are red
            window.colorScale = d3.scaleLinear()
                .domain([0, 0.5, 1])
                .range(["red", "white", "green"]);

            // Adding cells to the data table and displaying the data
            
            table.cells = table.rows.selectAll("td")
                .data(function (row) {
                    if(table.data[0]["Score"] === undefined){
                       
                        // Adding an additional "Score" column
                        return d3.keys(table.data[0]).map(function (column) {
                            return { column: column, value: row[column] };
                        }).concat([{ column: "Score", value: 0 }]);
                    }
                    else{
                        
                        return d3.keys(table.data[0]).map(function (column) {
                            return { column: column, value: row[column] };
                        });
                    }
                    
                    
                })
                .enter()
                .append("td")
                .attr("class", "table-cell cells"+table.index)
                .text(function (d) { return d.value; });
                table.cells.append("div")
                    .attr("class","cell-label")
                    .text(function (d) { return d.value; });
                table.cells.append("div")
                    .attr("class", "progress-bar")
                

            //<td>
            //    <p>td value</p>
            //    <div class='progressbar'/>
            //</td>

            
            // Updating colors and scores based on the initial data and settings
      
            
            
            updateScores(table);
            updateColors(table);
            calculateColumnMeans(table);

        }

        //<!-- ! Function to sort the data table when a header is clicked
        function sortTable(column, header, table) {

            table.headers.text(function (d) { return d; });
            if (table.sortColumn !== column) table.sortOrder = 0;
            table.sortColumn = column;

            // Sorting the data in descending, ascending, or original order
            if (table.sortOrder === 0) {
                table.rows.sort(function (a, b) {
                    // Check if the column data is numerical
                    if (!isNaN(a[column]) && !isNaN(b[column])) {
                        // Cast to float and sort
                        return d3.descending(parseFloat(a[column]), parseFloat(b[column]));
                    } else {
                        return d3.descending(a[column], b[column]);
                    }
                });
                header.textContent += ' â–¼';
                table.sortOrder++;
            } else if (table.sortOrder === 1) {
                table.rows.sort(function (a, b) {
                    // Check if the column data is numerical
                    if (!isNaN(a[column]) && !isNaN(b[column])) {
                        // Cast to float and sort
                        return d3.ascending(parseFloat(a[column]), parseFloat(b[column]));
                    } else {
                        return d3.ascending(a[column], b[column]);
                    }
                });
                header.textContent += ' â–²';
                table.sortOrder++;
            } else {
                table.rows.sort(function (a, b) {
                    var i = table.data.indexOf(a);
                    var j = table.data.indexOf(b);
                    return d3.ascending(i, j);
                });
                 
                table.sortOrder = 0;
            }
            
        }

        //<!-- ! Function to sort the data table based on already selected column and sortOrder
        function updateSort(table) {
            
            //Resetting the headers
            table.headers.text(function (d) { return d; });

            //Check if there is a column to sort on
            if (table.sortColumn === undefined || table.sortColumn === null ) return;
            
            

            column = table.sortColumn;
            header = d3.selectAll(".headers"+table.index).filter(function(d) { return d === column; }).node();
            
            // Sorting the data in descending, ascending, or original order
            if (table.sortOrder === 1) {
                table.rows.sort(function (a, b) {
                    return d3.descending(a[column], b[column]);
                });
                
                header.textContent += ' â–¼';
                
                
            } else if (table.sortOrder === 2) {
                table.rows.sort(function (a, b) {
                    return d3.ascending(a[column], b[column]);
                });
                
                header.textContent += ' â–²';
                
            } else {
                table.rows.sort(function (a, b) {
                    var i = table.data.indexOf(a);
                    var j = table.data.indexOf(b);
                    return d3.ascending(i, j);
                });
            }
            }

        //<!-- ! Function to sort the data table continuously when soting on score is active
        function sortScore(table) {

            //table.rows.data(table.data);
            if (table.sortOrder === 1) {
                table.rows.sort(function(a, b) {
                    return d3.descending(a["Score"], b["Score"]);
                });
            } else if (table.sortOrder === 2) {
                table.rows.sort(function(a, b) {
                    return d3.ascending(a["Score"], b["Score"]);
                });
            } else {
                table.rows.data(table.originalData).order();
                table.rows.sort(function(a, b) {
                    var i = table.data.indexOf(a);
                    var j = table.data.indexOf(b);
                    return d3.ascending(i, j);
                });
            }
        }

        
        //<!-- ! Function to calculate and display the mean (average) of each column
        function calculateColumnMeans(table) {
            table.columnMeans = {};

            // Calculating the mean for each column
            table.keys.forEach(function(column) {
                var sum = 0;
                var count = 0;
                table.data.forEach(function(row) {
                    var value = row[column];
                    if (includedColumns[column]) {
                        if (!isNaN(parseFloat(value)) && isFinite(value)) {  // If the value is numeric
                            sum += parseFloat(value);
                            count++;
                        } else if (categoricalMappings[column] && categoricalMappings[column][value] !== undefined) {  // If the value is categorical and mapped
                            sum += categoricalMappings[column][value];
                            count++;
                        }
                    }
                });
                table.columnMeans[column] = count > 0 ? (sum / count).toFixed(2) : "N/A";  // Calculating the mean or displaying "N/A" if not applicable
            });

            // Calculating the mean for the "Score" column
            var scoreSum = 0;
            var scoreCount = 0;
            table.data.forEach(function(row) {
                if (!isNaN(parseFloat(row["Score"]))) {
                    scoreSum += parseFloat(row["Score"]);
                    scoreCount++;
                }
            });
            table.columnMeans["Score"] = scoreCount > 0 ? (scoreSum / scoreCount).toFixed(2) : "N/A";

            // Removing any existing mean row
            table.dataTbody.selectAll("tr.mean-row").remove();

            // Adding a new mean row to the data table
            var meanRow = table.dataTbody.append("tr").classed("mean-row", true);
            var meanCells = meanRow.selectAll("td")
                .data(d3.values(table.columnMeans))
                .enter()
                .append("td")
                .text(function(d) { return d; });

            meanCells.filter(":last-child").classed("score", true); // Adding the "score" class to the last cell

            // Updating colors after calculating means
            updateColors(table);
        }

        //<!-- ! Function to reset the Score min and max
        function resetScoreMinMax(){
            // Resetting the Score min and max
            if (globalMin["Score"] !== undefined){
                globalMin["Score"] = undefined;
                for (let i = 0; i < tableList.length; i++) {
                    tableList[i].minVal["Score"] = undefined;
                }
            }
            if(globalMax["Score"] !== undefined){
                globalMax["Score"] = undefined;
                for (let i = 0; i < tableList.length; i++) {
                    tableList[i].maxVal["Score"] = undefined;
                }
                
            }
        }

        //<!-- ! Function to update the scores in the data table
        function updateScores(table) {
            // Iterating on the rows to calculate the score
            table.rows.each(function(row) {
                // reseting the calculation variables
                var totalWeightedDistance = 0;
                var totalPriority = 0;
                var maxDist = 0;
                

                // Calculating the total weighted distance and total priority for each row
                for (var column in row) {
                    if (column !== "Score" && includedColumns[column]) {
                        var value = row[column];
                        
                        if (!isNaN(parseFloat(value)) && isFinite(value)) {  // If the value is numeric
                            // calculating the max distance for the column
                            maxDist += Math.abs(globalMin[column] - globalMax[column]);
                            // retrieving the ideal value for the column
                            var idealValue = idealValues[column] || 0;
                            //calcualing the distance from ideal
                            var distance = Math.abs(parseFloat(value) - idealValue);
                            //caculating the total weighted distance
                            totalWeightedDistance += priorities[column] * (maxDist !== 0 ? 1 - distance / maxDist : 0);
                            totalPriority += priorities[column];
                        } else if (categoricalMappings[column] && categoricalMappings[column][value] !== undefined) {  // If the value is categorical and mapped
                            maxDist += 200;
                            var idealValue = 100; 
                            var distance = Math.abs(categoricalMappings[column][value] - idealValue);
                            totalWeightedDistance += priorities[column] * (1 - distance / maxDist);
                            totalPriority += priorities[column];
                        }
                        
                    }
                }
                
                
                // Check if the scores are activated
                if (activateScores) {
                    row["Score"] = (totalPriority === 0 || totalWeightedDistance === 0) ? 0 : totalWeightedDistance / totalPriority;
                } else {
                    row["Score"] = 0;
                }
               

                // Update globalMin and globalMax for "Score"
                if (globalMin["Score"] === undefined || row["Score"] < globalMin["Score"]) {
                    globalMin["Score"] = row["Score"];
                    table.minVal["Score"] = row["Score"];
                }
                if (globalMax["Score"] === undefined || row["Score"] > globalMax["Score"]) {
                 
                    globalMax["Score"] = row["Score"];
                    table.maxVal["Score"] = row["Score"];
                }

                // Update the min and max for the "Score" column
                if (table.minVal["Score"] === undefined || row["Score"] < table.minVal["Score"]) {
                    table.minVal["Score"] = row["Score"];
                }
                if (table.maxVal["Score"] === undefined || row["Score"] > table.maxVal["Score"]) {
                    table.maxVal["Score"] = row["Score"];
                }
               

                // Check if the scores are activated
                if (activateScores) {
                    d3.select(this).selectAll("td").filter(":last-child")
                    .classed("score", true)
                    .each(function(d) { d.value = row["Score"]; }).text(row["Score"].toFixed(2));
                } else {
                    d3.select(this).selectAll("td").filter(":last-child").each(function(d) { d.value = row["Score"]; }).text("X");
                }
             
            });

            // Update sorting if sort column is "Score" and sortOrder !== 0
            if (table.sortColumn === "Score" && table.sortOrder !== 0) {
                sortScore(table);
            }

            // Updating column means after scores are updated
            calculateColumnMeans(table);
        }


        //<!-- ! Function to update the state of a column (included or not in calculations) when its checkbox is changed
        function updateColumnState(tableList) {
        
            var column = this.name;  // The name of the column is stored in the name attribute of the checkbox
            includedColumns[column] = this.checked;  // Updating the inclusion state based on the checkbox state

            // Updating the state of sliders based on the checkbox state
            sliderTbody.selectAll("tr").selectAll("td").each(function (d, i) {
                if (d === column) {
                    d3.select(this).selectAll("input").classed("disabled", !includedColumns[column]);
                }
            });

            resetScoreMinMax();
            // Updating colors and scores after changing the column state
            for (let i = 0; i < tableList.length; i++) {
                updateScores(tableList[i]);
            }
            for (let i= 0 ; i < tableList.length;i++){
                updateColors(tableList[i]);
            }
            
        }

        /**
         * ! The 'updateColors' function is responsible for updating the background color
         * ! of each cell in the data table based on its distance from an ideal value.
         */
         function updateColors(table) {

            
            // Using D3, select all 'td' elements (cells) in the data table and set their 'background-color' style.
            table.cells.selectAll('.progress-bar').style("background-color", function (d) {
                // <!-- * CATHEGOICAL colors
                if (!activateColors && !activateBars ){return null;}
                else if(!activateColors && activateBars){ return "Silver"}

                // Check if the value in the cell is non-numeric (categorical).
                if (isNaN(parseFloat(d.value)) && includedColumns[d.column]) {
                    // Check if there is a mapping for the categorical value.
                    if (categoricalMappings[d.column] && categoricalMappings[d.column][d.value] !== undefined) {
                        // Retrieve the mapped score for the categorical value.
                        var mappedValue = categoricalMappings[d.column][d.value];
                        // Set the ideal value for mapped categorical data to 100.
                        var idealMappedValue = 100;
                        // Calculate the absolute distance between the mapped value and the ideal value.
                        var distance = Math.abs(mappedValue - idealMappedValue);
                        // Set the maximum possible distance for mapped categorical data to 100.
                        var maxDistance = 200;
                        var result;
                        // <!-- ~ Return a color from the scale based on the normalized distance from the ideal value. 
                        if (colorMetric === "Distance"){
                            result = colorScale(1 - distance / maxDistance);
                        }
                        // <!-- ~ Return a color from the scale based on the priority value. 
                        else if (colorMetric === "Priority"){
                            result = colorScale(priorities[d.column]/100);
                        }
                        // <!-- ~ Return a color from the scale based on the a normalized product of the distance from the ideal and priority.
                        else if (colorMetric === "DistanceXPriority"){
                            result = maxDistance !== 0 ? colorScale(1 - ((distance/maxDistance)*priorities[d.column])/100) : 0; 
                            
                        }
                        

                        return result;
                        
                    }
                    // If the value is non-numeric and has no mapping, return null (no background color).
                    return null;
                }
                
                
                

                // For numeric columns, calculate the minimum and maximum values in the column.
                var minVal = globalMin[d.column];
                var maxVal = globalMax[d.column];
                
                // <!-- * NUMERICAL colors
                // Check if minimum and maximum values are defined.
                if (minVal !== undefined && maxVal !== undefined && includedColumns[d.column]) {
                    
                    // Retrieve the ideal value for the column.
                    var idealValue = idealValues[d.column];
                    // Calculate the absolute distance between the actual value and the ideal value.
                    var distance = Math.abs(parseFloat(d.value) - idealValue);
                    // Calculate the maximum possible distance from the ideal value in the column.
                    var maxDistance = Math.max(Math.abs(maxVal - idealValue), Math.abs(minVal - idealValue));
                    // Return a color from the scale based on the normalized distance from the ideal value.
                    var result;
                    // <!-- ~ Return a color from the scale based on the normalized distance from the ideal value.
                    if (colorMetric === "Distance"){
                        result =  colorScale(maxDistance !== 0 ? 1 - distance / maxDistance : 0);
                    }
                    // <!-- ~ Return a color from the scale based on the priority value.
                    else if (colorMetric === "Priority"){
                        result =  colorScale(priorities[d.column]/100);
                    }
                    // <!-- ~ Return a color from the scale based on the normalized distance from the ideal value.
                    else if (colorMetric === "DistanceXPriority"){
                        result =  colorScale(maxDistance !== 0 ? 1 - ((distance/maxDistance)*priorities[d.column])/100 : 0);       
                    }
                    return result;
                    
                } else {
                    // If minimum and maximum values are not defined, return null (no background color).
                    return null;
                }
            });

            
            if(activateBars){
                // create bars to show priority
                table.rows.selectAll("td").selectAll(".progress-bar").style("width", function(d) {
                    // <!-- * CATHEGOICAL bars
                    if (isNaN(parseFloat(d.value)) && includedColumns[d.column] ) {

                        var idealValue = 100;
                        var distance = Math.abs(categoricalMappings[d.column][d.value] - idealValue);
                        var maxDistance = 200

                        var result;
                        //const prioritySum = Object.values(priorities).reduce((prev,curr) => curr+prev, 0);
                        // <!-- ~ Return a color from the scale based on the normalized distance from the ideal value.
                        if (barsMetric === "Distance"){
                            result = maxDistance !== 0 ? (1 - distance / maxDistance)*100 : 0;
                        }
                        // <!-- ~ Return a color from the scale based on the priority value.
                        else if (barsMetric === "Priority"){
                            result = priorities[d.column];
                        }
                        // <!-- ~ Return a color from the scale based on the a normalized product of the distance from the ideal and priority.
                        else if (barsMetric === "DistanceXPriority"){
                            result = maxDistance !== 0 ? (((1-distance/maxDistance)*priorities[d.column])/100) * 100 : 100;
                        }

                        return result+"%" ;
                    }


                    // <!-- * NUMERICAL bars
                    if(!isNaN(parseFloat(d.value)) && includedColumns[d.column] && d.column!== "Score" ){
                        var idealValue = idealValues[d.column];
                            var distance = Math.abs(parseFloat(d.value) - idealValue);
                            //var numericValues = table.data.map(function(row) { return parseFloat(row[d.column]); }).filter(function(val) { return !isNaN(val); });
                            var minVal = globalMin[d.column]
                            var maxVal = globalMax[d.column] 
                            var maxDistance = Math.max(Math.abs(maxVal - idealValue), Math.abs(minVal - idealValue));

                            if(maxDistance === 0){
                                return 1 ;
                            }
                            console.log( distance, minVal, maxVal, idealValue, maxDistance)
                            var result;
                            // <!-- ~ Return a color from the scale based on the normalized distance from the ideal value.
                            if(barsMetric === "Distance"){
                                result = maxDistance !== 0 ? (1 - distance / maxDistance)*100 : 0;
                                //const prioritySum = Object.values(priorities).reduce((prev,curr) => curr+prev, 0);
                            }
                            // <!-- ~ Return a color from the scale based on the priority value.
                            else if(barsMetric === "Priority"){
                                result = priorities[d.column];
                            }
                            // <!-- ~ Return a color from the scale based on the a normalized product of the distance from the ideal and priority.
                            else if(barsMetric === "DistanceXPriority"){
                                // result should be between 0 and 100 and is the value for the normalized distance from the ideal value times the priority
                                result = maxDistance !== 0 ? (((1-distance/maxDistance)*priorities[d.column])/100) * 100 : 100;
                                
                            }else{
                                result = 0 ;
                            }
                            return result+"%"
                    }
                    else if(d.column === "Score"){
                        // display the score with a full bar
                        return 1;
                    }
                    else{
                        return 0;
                    }
                    
                });
            }else{
                table.cells.selectAll('.progress-bar').style("width", "100%" )
            }


            // <!-- * OPACITY CONTROL
            table.rows.selectAll("td").style("opacity", function(d) {
                if (!activateOpacity){
                    return 1;
                }
                if (d.column === "Score"){
                        return 1;
                }
                if (includedColumns[d.column]){
                    if(isNaN(parseFloat(d.value))){
                        var idealValue = 100;
                        var distance = Math.abs(categoricalMappings[d.column][d.value] - idealValue);
                        var maxDistance = 200
                    }else{
                        var idealValue = idealValues[d.column];
                        var distance = Math.abs(parseFloat(d.value) - idealValue);
                        //var numericValues = table.data.map(function(row) { return parseFloat(row[d.column]); }).filter(function(val) { return !isNaN(val); });
                        var minVal = globalMin[d.column]
                        var maxVal = globalMax[d.column] 
                        var maxDistance = Math.max(Math.abs(maxVal - idealValue), Math.abs(minVal - idealValue));

                    }
                    
                         
                    var result;
                    // <!-- ~ Return a color from the scale based on the normalized distance from the ideal value.
                    if(opacityMetric === "Distance"){
                        result = maxDistance !== 0 ? 0.75 * (1 - distance / maxDistance) + 0.25 : 0.25;
                        //const prioritySum = Object.values(priorities).reduce((prev,curr) => curr+prev, 0);
                    }
                    // <!-- ~ Return a color from the scale based on the priority value.
                    else if(opacityMetric === "Priority"){
                        result = 0.75 * (priorities[d.column] / 100) + 0.25;
                    }
                    // <!-- ~ Return a color from the scale based on the a normalized product of the distance from the ideal and priority.
                    else if(opacityMetric === "DistanceXPriority"){
                        result = maxDistance  !== 0 ? 0.75 * (1 - ((distance/maxDistance)*priorities[d.column])/100) + 0.25 : 0.25;

                        console.log(result)
                    }else{
                        result = 0.25 ;
                    }
                    return result
                }else{
                    return 0.20;
                }
            });
            
         
            

            // Update color scale for scores
            var minScore = globalMin["Score"];
            var maxScore = globalMax["Score"];
            
            
            // update the score's color
            table.rows.selectAll("td").filter(":last-child").style("background-color", function(d) {
                if(!activateColors){ return null;}
                return colorScale(parseFloat(d.value));
            });

            // <!-- * MEAN colors
            // Update color for mean row including the mean of the Score column
            table.dataTbody.selectAll("tr.mean-row").selectAll("td")
            .style("background-color", function(d, i) {
                if (!activateColors){return null;}

                var column = table.keys.concat(["Score"])[i];
                if (column === "Score" && !isNaN(parseFloat(d))) {
                    return (maxScore !== minScore) ? colorScale(parseFloat(d)) : colorScale(0);
                } else if (includedColumns[column] && !isNaN(parseFloat(d))) {
                    var idealValue = idealValues[column];
                    var distance = Math.abs(parseFloat(d) - idealValue);
                    var minVal = globalMin[column];
                    var maxVal = globalMax[column];
                    var maxDistance = Math.max(Math.abs(maxVal - idealValue), Math.abs(minVal - idealValue));
                    if(idealValue !== undefined){
                        return maxDistance !== 0 ? colorScale(1 - distance / maxDistance) : colorScale(0);   
                    }else{
                        return colorScale(1 - (100-d) / 200) 
                    }
                    
                } else {
                    return null;
                }
            });

        }



    </script>
</body>
</html>
